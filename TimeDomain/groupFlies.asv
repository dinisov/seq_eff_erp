function ALLFLIES = groupFlies(FLIES, chosenFlies)

ALLFLIES = struct;

%matrices to hold SE profiles for each fly
amplitudeSEs = zeros(16,length(chosenFlies));
negativeAmplitudeSEs = zeros(16,length(chosenFlies));
positiveAmplitudeSEs = zeros(16,length(chosenFlies));
latencyToPeakSEs = zeros(16,length(chosenFlies));
latencyToTroughSEs = zeros(16,length(chosenFlies));
nERPsFly = zeros(1,length(chosenFlies));

semAmplSEs = zeros(16,length(chosenFlies));
semPosAmplSEs = zeros(16,length(chosenFlies));
semNegAmplSEs = zeros(16,length(chosenFlies));

%collect profiles and errors in matrix
for fly = 1:length(chosenFlies)

        %number of ERPs for each fly (summing over sequences)
        nERPsFly(fly) = sum(FLIES(chosenFlies(fly)).nERPs);
        
        %sequential effects results
        amplitudeSEs(:,fly) = (FLIES(chosenFlies(fly)).PROFILE.amplitude.')*nERPsFly(fly);
        positiveAmplitudeSEs(:,fly) = (FLIES(chosenFlies(fly)).PROFILE.positiveAmplitude.')*nERPsFly(fly);
        negativeAmplitudeSEs(:,fly) = (FLIES(chosenFlies(fly)).PROFILE.negativeAmplitude.')*nERPsFly(fly);
        latencyToPeakSEs(:,fly) = (FLIES(chosenFlies(fly)).PROFILE.latencyToPeak.')*nERPsFly(fly);
        latencyToTroughSEs(:,fly) = (FLIES(chosenFlies(fly)).PROFILE.latencyToTrough.')*nERPsFly(fly);
        
        %standard errors for each fly
        semAmplSEs(:,fly) = FLIES(chosenFlies(fly)).ERROR.amplitude;
        semPosAmplSEs(:,fly) = FLIES(chosenFlies(fly)).ERROR.positiveAmplitude;
        semNegAmplSEs(:,fly) = FLIES(chosenFlies(fly)).ERROR.negativeAmplitude; 
            
end

%divide SE profiles by total number of ERPs to finish weighted average
amplitudeSEs = sum(amplitudeSEs,2)/sum(nERPsFly);
positiveAmplitudeSEs = sum(positiveAmplitudeSEs,2)/sum(nERPsFly);
negativeAmplitudeSEs = sum(negativeAmplitudeSEs,2)/sum(nERPsFly);
latencyToPeakSEs = sum(latencyToPeakSEs,2)/sum(nERPsFly);
latencyToTroughSEs = sum(latencyToTroughSEs,2)/sum(nERPsFly);

%calculate errors by propagating errors from individual flies
for fly = 1:length(chosenFlies)
        % part of the error propagation calculation (n_A^2*sem_A^2)
        semAmplSEs(:,fly) = semAmplSEs(:,fly).^2 * nERPsFly(fly).^2;
        semPosAmplSEs(:,fly) = semPosAmplSEs(:,fly).^2 * nERPsFly(fly).^2;
        semNegAmplSEs(:,fly) = semNegAmplSEs(:,fly).^2 * nERPsFly(fly).^2;
end

%finish calculating error propagation
% sem_{(n_A*A + n_B*B)/(n_A+n_B)^2} = sqrt(n_A^2/(n_A+n_B)^2 sem_A^2 + n_B^2/(n_A+n_B)^2 sem_B^2)
semAmplSEs = sqrt(sum(semAmplSEs/(sum(nERPsFly)^2),2));
semPosAmplSEs = sqrt(sum(semPosAmplSEs/(sum(nERPsFly)^2),2));
semNegAmplSEs = sqrt(sum(semNegAmplSEs/(sum(nERPsFly)^2),2));

% add matrices with all profiles to ALLFLIES structure (ignores LIT vs DARK)
ALLFLIES.PROFILE.amplitude = amplitudeSEs.';
ALLFLIES.PROFILE.positiveAmplitude = positiveAmplitudeSEs.';           
ALLFLIES.PROFILE.negativeAmplitude = negativeAmplitudeSEs.';
ALLFLIES.PROFILE.latencyToPeak = latencyToPeakSEs.';
ALLFLIES.PROFILE.latencyToTrough = latencyToTroughSEs.';

ALLFLIES.nERPsFly = nERPsFly.';

%propagated errors
ALLFLIES.ERROR.amplitude = semAmplSEs.';
ALLFLIES.ERROR.positiveAmplitude = semPosAmplSEs.';
ALLFLIES.ERROR.negativeAmplitude = semNegAmplSEs.';