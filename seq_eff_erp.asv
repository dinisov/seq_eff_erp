% analyse sequential dependencies in fly ERPs
close all;
clear;

%% load auxiliary functions
addpath('../');
addpath('..\Scripts\Global functions\');
addpath('..\Scripts\Indexes and legends\');
addpath('Functions');

% load peak finder (Matt's code)
addpath('..\Scripts\Toolboxes\basefindpeaks\');

% load slrp_lrpr

% load results

% these are the standard ALT/REP components from the literature (Jentzsch 2002)
% lrpr = normalize(-lrpr); slrp = normalize(slrp); weird = normalize(weird);

%% type of analysis

% if block experiment, choose which stimulus to look in the train (starting at 5 up to train length)
focusPeak = 5;

% analysis mode ('time' or 'timefrequency')
analysisMode = 'timefrequency';

%% toggles

%error method (0 - a la Bruno and Matt; 1- propagation )
errorMethod = 0;

% fit model
fitModel = 1;

%plot individual flies?
plotIndividualFlies = 1;

%which SEs to plot (in order: amplitude, pos amplitude, neg amplitude, latency to peak, latency to trough)
plotSelector = [1 1 1 0 0];

% whether to plot auxiliary plots (some are always plotted)
aux_plots = 1;

%% load data
homeDirectory = '../../Bruno';

resultsDirectory = [homeDirectory '/Results/12dot5Hz/'];

struct_name = 'freq12dot5hz';

fly_record = readtable([homeDirectory '/Fly record/fly_record']);

%% restrict to some frequency
% fly_record = fly_record(fly_record.Frequency == 12.5,:);

%% restrictions on data of interest; always check this before running

% remove DARK flies
fly_record = fly_record(convertCharsToStrings(fly_record.Condition) == 'LIT',:);

% remove flies to be excluded (usually because data is unsound for some obvious reason)
fly_record = fly_record(~logical(fly_record.Exclude),:);

%remove jittering flies
fly_record = fly_record(~contains(fly_record.Comments,'jitter','IgnoreCase',true),:);

%remove red light flies
% fly_record = fly_record(~contains(fly_record.Comments,'red','IgnoreCase',true),:);

%restrict to red1 flies
%fly_record = fly_record(contains(fly_record.Comments,'red1','IgnoreCase',true),:);

%remove block paradigm flies
% fly_record = fly_record(~contains(fly_record.Comments,'block','IgnoreCase',true),:);

% 
%  fly_record = fly_record(contains(fly_record.Comments,'recovery2','IgnoreCase',true),:);

%% choose flies and experiments
whichFly =      fly_record.Fly.';
flySet = unique(whichFly);

% choose which flies to run here
chosenFlies = [39];
% chosenFlies = setdiff(flySet, [24 25]);
%  chosenFlies = flySet; % choose all flies
% chosenFlies = setdiff(chosenFlies, 24:29);

%for testing
% chosenFlies = chosenFlies(1:2);

% choose which blocks to run
%NOTE: while unlikely as a request, this does not handle the case where two
%flies have a block with the same number but we would like to look at both
%flies but not one of the blocks with the same number
chosenBlocks = [43];
%  chosenBlocks = unique(fly_record.Block.');% do not choose specific blocks

chosenOnes = ismember(fly_record.Block.', chosenBlocks) & ismember(fly_record.Fly.', chosenFlies);

%% add data to structure according to block
% the structure may be largely empty if analysing only one fly
% the index here is that of the fly_record table, *not* the original block number

BLOCKS = struct;

% loop though all blocks, irrespective of experiment
for b = find(chosenOnes)
    
    date = datestr(fly_record.Date(b),'ddmmyy');
    block = num2str(fly_record.Block(b));

    % load this block's data
    load([homeDirectory '/SEoutput/' date '/LFP/Analyzed_TagTrials_block' block '/' date '_chunk_0']);
    
    % photodiode and lfp data
    LFP = EEG.LFP1.data(fly_record.LFPChannel(b),:);
    PHOT = EEG.PHOT.data;
    rawPHOT = EEG.PHOT.data; %preserve raw unfiltered photodiode data
    resampleFreq = EEG.srate;
    
    % remove first/last n_sec seconds of recording
    n_sec = 1;
    chunk_a_time = n_sec*resampleFreq;
    LFP = LFP(:,chunk_a_time:end-chunk_a_time);
    PHOT = PHOT(:,chunk_a_time:end-chunk_a_time);
    rawPHOT = rawPHOT(:,chunk_a_time:end-chunk_a_time);
    
    %%
    
    % correct for the fact that the left photodiode is inverted
    % such that peaks are always upward for peak detection
    if strcmp(fly_record.Condition(b),'LIT')
        PHOT(2,:) = -PHOT(2,:);
        rawPHOT(2,:) = -rawPHOT(2,:);
    else
        PHOT(1,:) = -PHOT(1,:); 
        rawPHOT(1,:) = -rawPHOT(1,:);
    end
    
%     PHOT(3,:) = -PHOT(3,:);
    
    LFP = filterLFP(LFP, re)


    % butterworth filter LFP
    [b_f,a_f] = butter(6,100/resampleFreq*2);
    LFP = filter(b_f,a_f,LFP.').';

    %notch filter at 50Hz
    wo = 50/(resampleFreq/2);  
    bw = wo/10;
    [b_f,a_f] = iirnotch(wo,bw);

    LFP = filter(b_f,a_f,LFP.').';
    
    % savitsky-golay filter
    LFP = smoothdata(LFP,'sgolay');

    PHOT = trim_phot_outliers(PHOT, 12);
    
    %% remove anything from LFP beyond some sd
        
    if ~isnan(fly_record.LFPsd(b))
    
        n_sd_lfp = fly_record.LFPsd(b);
        sd_lfp = std(LFP); mean_lfp = mean(LFP);
        
        % do a nice plot
        if aux_plots
            figure; plot(LFP); hold on; %#ok<*UNRCH>
            x_lim = xlim;
            plot([x_lim(1) x_lim(2)],[mean_lfp-n_sd_lfp*sd_lfp mean_lfp-n_sd_lfp*sd_lfp],'r');
            plot([x_lim(1) x_lim(2)],[mean_lfp+n_sd_lfp*sd_lfp mean_lfp+n_sd_lfp*sd_lfp],'r');
        end
            
        % nuke everything beyond +/- the set number of sd
        LFP(LFP > mean_lfp+n_sd_lfp*sd_lfp | LFP < mean_lfp-n_sd_lfp*sd_lfp) = NaN;

    end
    
    %% 
    
%     figure; plot(rawPHOT(2,:)); hold on; plot(PHOT(2,:));

%     figure; plot(PHOT(1,:)); hold on; plot(xlim, [photSD photSD]); plot(xlim, [-photSD -photSD]);
%     figure; plot(PHOT(2,:)); hold on; plot(xlim, [photSD photSD]); plot(xlim, [-photSD -photSD]);

    BLOCKS(b).LFP = LFP;
    BLOCKS(b).PHOT = PHOT;
    BLOCKS(b).rawPHOT = rawPHOT;
    
    BLOCKS(b).times = EEG.times;
    BLOCKS(b).resampleFreq = resampleFreq;
    
    % only for block experiments
    BLOCKS(b).interBlockPeriod = fly_record.InterBlockPeriod(b);
    BLOCKS(b).focusPeak = focusPeak;
    BLOCKS(b).blockLength = fly_record.BlockLength(b);
    
    % if this is a block experiment and the focus peak is the last in the
    % train, disregard the window setting and look at the entire period
    % between blocks (both for time-domain and time-frequency analyses)
    if ~isnan(fly_record.BlockLength(b)) && (focusPeak == BLOCKS(b).blockLength) 
        BLOCKS(b).time_before_peak = 0;
        BLOCKS(b).time_after_peak = fly_record.InterBlockPeriod(b);
    else
        BLOCKS(b).time_before_peak = fly_record.SDT(b).*fly_record.Window1(b);
        BLOCKS(b).time_after_peak = fly_record.ISI(b).*fly_record.Window2(b);
    end
    
    BLOCKS(b).ISI = fly_record.ISI(b) + fly_record.SDT(b);
%     BLOCKS(b).SDT = fly_record.SDT(b);
    BLOCKS(b).peakThreshold = fly_record.Threshold(b);
    
    % whether to do a 1 or 2 photodiode analysis
    % 2 is better currently but 1 is more universal/convenient
    BLOCKS(b).PHOTType = fly_record.PHOTType(b);

end

%% analyse data for each fly (can include multiple blocks)
% IMPORTANT: make sure window is the same for all blocks
for fly = chosenFlies
       
   % index of the blocks belonging to this fly if they are to be
   % included in the analysis
   thisFlyBlocks = BLOCKS(whichFly == fly & chosenOnes);

   disp(['Processing fly #' num2str(fly)]);

   R = processBlocks(thisFlyBlocks, aux_plots);
   
   FLIES(fly) = R; %#ok<SAGROW>
   
end

%% fit individual flies (can easily be expanded to include fits not just to amplitude)
if fitModel
    for fly = chosenFlies
        FLIES(fly).FIT = fitFlyModel(FLIES(fly));
    end
end

%% plot sequential dependencies per fly (if model results exist they are plotted)
if plotIndividualFlies
    plotFlies(FLIES, chosenFlies, plotSelector, resultsDirectory);
end

%% calculate SEs for all flies by averaging SE profiles
if length(chosenFlies) > 1
    ALLFLIES = groupFlies(FLIES, chosenFlies, errorMethod);
    
    %% fit model to grouped data
    if fitModel
        ALLFLIES.FIT = fitFlyModel(ALLFLIES);
    end
    
    %% plot grouped SE profiles
    plotFlies(ALLFLIES,chosenFlies,plotSelector,[resultsDirectory 'All flies/']);
end

%% time-frequency analysis
